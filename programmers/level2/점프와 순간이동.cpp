/*
  목적지까지 이동하는데 최소 비용을 구해야 한다.
  순간이동은 현재 위치 m * 2 로 이동할 수 있고 비용은 0이 든다. 그리고 한 칸이동하면 cost 1이 소모된다.
  n은 10억까지 범위이기에 for문이나 재귀로는 구할 수 없다.
  2의 배수는 순간이동으로 전부 cost 0을 소모하고 움직일 수 있다. 그렇다면 홀수 위치일때 다시 짝수 위치로 가기 위한 cost값만 소모하면 된다.
  따라서 n이 짝수이면 2로 나눠주고, 홀수이면 -1 을 해서, 원점 위치인 1로 돌아올때까지 이 과정을 반복해준다.
*/
using namespace std;

int solution(int n)
{
    int ans = 0;
    
    int now = 1; // 무조건 한칸은 최소 움직여야함, 따라서 cost 는 1에서 시작.
    ans += 1;
    
    while(n != 1){
        if(n % 2 == 0) n/=2;
        else if(n % 2 == 1){
            ans += 1;
            n -= 1;
        }
    }
    
    return ans;
}
